/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  CosmWasmClient,
  SigningCosmWasmClient,
  ExecuteResult,
} from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import {
  Uint128,
  Timestamp,
  Uint64,
  InstantiateMsg,
  BaseDenom,
  ServiceFeeConfig,
  ExecuteMsg,
  RebalancerAdminMsg,
  SystemRebalanceStatus,
  Pair,
  Decimal,
  Addr,
  Expiration,
  TargetOverrideStrategy,
  OptionalFieldForUint64,
  OptionalFieldForString,
  RebalancerData,
  PID,
  Target,
  RebalancerUpdateData,
  QueryMsg,
  QueryFeeAction,
  SignedDecimal,
  ArrayOfTupleOfAddrAndRebalancerConfig,
  RebalancerConfig,
  ParsedPID,
  ParsedTarget,
  ManagersAddrsResponse,
  PauseReason,
  PauseData,
  NullableCoin,
  Coin,
  WhitelistsResponse,
} from "./Rebalancer.types";
export interface RebalancerReadOnlyInterface {
  contractAddress: string;
  getConfig: ({ addr }: { addr: string }) => Promise<RebalancerConfig>;
  getAllConfigs: ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<ArrayOfTupleOfAddrAndRebalancerConfig>;
  getPausedConfig: ({ addr }: { addr: string }) => Promise<PauseData>;
  getServiceFee: ({
    account,
    action,
  }: {
    account: string;
    action: QueryFeeAction;
  }) => Promise<NullableCoin>;
}
export class RebalancerQueryClient implements RebalancerReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getConfig = this.getConfig.bind(this);
    this.getAllConfigs = this.getAllConfigs.bind(this);
    this.getPausedConfig = this.getPausedConfig.bind(this);
    this.getServiceFee = this.getServiceFee.bind(this);
  }
  getConfig = async ({ addr }: { addr: string }): Promise<RebalancerConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_config: {
        addr,
      },
    });
  };
  getAllConfigs = async ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<ArrayOfTupleOfAddrAndRebalancerConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_configs: {
        limit,
        start_after: startAfter,
      },
    });
  };
  getPausedConfig = async ({ addr }: { addr: string }): Promise<PauseData> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_paused_config: {
        addr,
      },
    });
  };
  getServiceFee = async ({
    account,
    action,
  }: {
    account: string;
    action: QueryFeeAction;
  }): Promise<NullableCoin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_service_fee: {
        account,
        action,
      },
    });
  };
}
export interface RebalancerInterface extends RebalancerReadOnlyInterface {
  contractAddress: string;
  sender: string;
  admin: (
    rebalancerAdminMsg: RebalancerAdminMsg,
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  systemRebalance: (
    {
      limit,
    }: {
      limit?: number;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  register: (
    {
      data,
      registerFor,
    }: {
      data?: RebalancerData;
      registerFor: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  deregister: (
    {
      deregisterFor,
    }: {
      deregisterFor: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  update: (
    {
      data,
      updateFor,
    }: {
      data: RebalancerUpdateData;
      updateFor: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  pause: (
    {
      pauseFor,
      reason,
      sender,
    }: {
      pauseFor: string;
      reason?: string;
      sender: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  resume: (
    {
      resumeFor,
      sender,
    }: {
      resumeFor: string;
      sender: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
}
export class RebalancerClient
  extends RebalancerQueryClient
  implements RebalancerInterface
{
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string
  ) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.admin = this.admin.bind(this);
    this.systemRebalance = this.systemRebalance.bind(this);
    this.register = this.register.bind(this);
    this.deregister = this.deregister.bind(this);
    this.update = this.update.bind(this);
    this.pause = this.pause.bind(this);
    this.resume = this.resume.bind(this);
  }
  admin = async (
    rebalancerAdminMsg: RebalancerAdminMsg,
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        admin: rebalancerAdminMsg,
      },
      fee,
      memo,
      _funds
    );
  };
  systemRebalance = async (
    {
      limit,
    }: {
      limit?: number;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        system_rebalance: {
          limit,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  register = async (
    {
      data,
      registerFor,
    }: {
      data?: RebalancerData;
      registerFor: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        register: {
          data,
          register_for: registerFor,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  deregister = async (
    {
      deregisterFor,
    }: {
      deregisterFor: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        deregister: {
          deregister_for: deregisterFor,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  update = async (
    {
      data,
      updateFor,
    }: {
      data: RebalancerUpdateData;
      updateFor: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update: {
          data,
          update_for: updateFor,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  pause = async (
    {
      pauseFor,
      reason,
      sender,
    }: {
      pauseFor: string;
      reason?: string;
      sender: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        pause: {
          pause_for: pauseFor,
          reason,
          sender,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  resume = async (
    {
      resumeFor,
      sender,
    }: {
      resumeFor: string;
      sender: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        resume: {
          resume_for: resumeFor,
          sender,
        },
      },
      fee,
      memo,
      _funds
    );
  };
}
