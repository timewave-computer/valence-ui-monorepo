/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * We need some way of knowing which domain we are talking with chain connection, execution, bridges for authorization.
 */
export type Domain = {
  CosmosCosmwasm: string;
};
/**
 * What account type we talking about
 */
export type AccountType =
  | {
      Addr: {
        addr: string;
      };
    }
  | {
      Base: {
        admin?: string | null;
      };
    };
export type AuthorizationDuration =
  | "forever"
  | {
      seconds: number;
    }
  | {
      blocks: number;
    };
export type AuthorizationModeInfo =
  | "permissionless"
  | {
      permissioned: PermissionTypeInfo;
    };
export type PermissionTypeInfo =
  | {
      with_call_limit: [string, Uint128][];
    }
  | {
      without_call_limit: string[];
    };
/**
 * A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.
 *
 * # Examples
 *
 * Use `from` to create instances of this and `u128` to get the value out:
 *
 * ``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);
 *
 * let b = Uint128::from(42u64); assert_eq!(b.u128(), 42);
 *
 * let c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```
 */
export type Uint128 = string;
/**
 * Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)
 */
export type Expiration =
  | {
      at_height: number;
    }
  | {
      at_time: Timestamp;
    }
  | {
      never: {};
    };
/**
 * A point in time in nanosecond precision.
 *
 * This type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.
 *
 * ## Examples
 *
 * ``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);
 *
 * let ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```
 */
export type Timestamp = Uint64;
/**
 * A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.
 *
 * # Examples
 *
 * Use `from` to create instances of this and `u64` to get the value out:
 *
 * ``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);
 *
 * let b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```
 */
export type Uint64 = string;
export type Priority = "medium" | "high";
export type Subroutine =
  | {
      atomic: AtomicSubroutine;
    }
  | {
      non_atomic: NonAtomicSubroutine;
    };
/**
 * An account type that is used in the library configs It can either be an Id or Addr The config that will be passed to the library must be of Addr veriant
 */
export type LibraryAccountType =
  | {
      "|library_account_addr|": string;
    }
  | {
      "|account_id|": number;
    }
  | {
      "|library_id|": number;
    };
export type Domain2 =
  | "main"
  | {
      external: string;
    };
export type ParamRestriction =
  | {
      must_be_included: string[];
    }
  | {
      cannot_be_included: string[];
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      must_be_value: [string[], Binary];
    };
/**
 * Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.
 *
 * This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.
 */
export type Binary = string;
export type MessageType = "cosmwasm_execute_msg" | "cosmwasm_migrate_msg";
/**
 * Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined
 */
export type Duration =
  | {
      height: number;
    }
  | {
      time: number;
    };
export type RetryTimes =
  | "indefinitely"
  | {
      amount: number;
    };
/**
 * A human readable address.
 *
 * In Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.
 *
 * This type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.
 *
 * This type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.
 */
export type Addr = string;
export type AuthorizationInfoUpdate =
  | {
      Add: AuthorizationInfo;
    }
  | {
      Modify: {
        expiration?: Expiration | null;
        label: string;
        max_concurrent_executions?: number | null;
        not_before?: Expiration | null;
        priority?: Priority | null;
      };
    }
  | {
      Disable: string;
    }
  | {
      Enable: string;
    };

export interface SanitizedProgramConfig {
  program_config: ProgramConfig;
  program_config_update: ProgramConfigUpdate;
}
export interface ProgramConfig {
  /**
   * The list account data by id
   */
  accounts: {
    [k: string]: AccountInfo;
  };
  /**
   * This is the info regarding authorization and processor contracts. Must be empty (Default) when a new program is instantiated. It gets populated when the program is instantiated.
   */
  authorization_data?: AuthorizationData;
  /**
   * A list of authorizations
   */
  authorizations: AuthorizationInfo[];
  id?: number;
  /**
   * The list service data by id
   */
  libraries: {
    [k: string]: LibraryInfo;
  };
  /**
   * A list of links between an accounts and libraries
   */
  links: {
    [k: string]: Link;
  };
  owner: string;
}
/**
 * The struct given to us by the user.
 *
 * We need to know what domain we are talking with and what type of account we should work with.
 */
export interface AccountInfo {
  addr?: string | null;
  domain: Domain;
  name: string;
  ty: AccountType;
}
/**
 * This struct holds all the data regarding our authorization and processor contracts and bridge accounts
 */
export interface AuthorizationData {
  /**
   * authorization contract address on neutron
   */
  authorization_addr: string;
  /**
   * List of authorization bridge addresses by domain The addresses are on the specified domain Key: domain name | Value: authorization bridge address on that domain
   */
  authorization_bridge_addrs: {};
  /**
   * List of processor addresses by domain Key: domain name | Value: processor address
   */
  processor_addrs: {};
  /**
   * List of processor bridge addresses by domain All addresses are on nuetron, mapping to what domain this bridge account is for Key: domain name | Value: processor bridge address on that domain
   */
  processor_bridge_addrs: {};
}
export interface AuthorizationInfo {
  duration: AuthorizationDuration;
  label: string;
  max_concurrent_executions?: number | null;
  mode: AuthorizationModeInfo;
  not_before: Expiration;
  priority?: Priority | null;
  subroutine: Subroutine;
}
export interface AtomicSubroutine {
  functions: AtomicFunction[];
  retry_logic?: RetryLogic | null;
}
export interface AtomicFunction {
  contract_address: LibraryAccountType;
  domain: Domain2;
  message_details: MessageDetails;
}
export interface MessageDetails {
  message: Message;
  message_type: MessageType;
}
export interface Message {
  name: string;
  params_restrictions?: ParamRestriction[] | null;
}
export interface RetryLogic {
  interval: Duration;
  times: RetryTimes;
}
export interface NonAtomicSubroutine {
  functions: NonAtomicFunction[];
}
export interface NonAtomicFunction {
  callback_confirmation?: FunctionCallback | null;
  contract_address: LibraryAccountType;
  domain: Domain2;
  message_details: MessageDetails;
  retry_logic?: RetryLogic | null;
}
export interface FunctionCallback {
  callback_message: Binary;
  contract_address: Addr;
}
export interface LibraryInfo {
  addr?: string | null;
  domain: Domain;
  name: string;
  config?: {
    [k: string]: unknown;
  };
}
export interface Link {
  /**
   * List of input accounts by id
   */
  input_accounts_id: number[];
  /**
   * The library id
   */
  library_id: number;
  /**
   * List of output accounts by id
   */
  output_accounts_id: number[];
}
/**
 * The job of the update, is to output a set of instructions to the user to update the program configuration. The user can only update library configs and authorizations.
 */
export interface ProgramConfigUpdate {
  /**
   * A list of authorizations
   */
  authorizations: AuthorizationInfoUpdate[];
  /**
   * This is the id of the program Required for update
   */
  id: number;
  /**
   * The list library data by id
   */
  libraries: {};
  /**
   * New owner, if the owner is to be updated
   */
  owner?: string | null;
}
