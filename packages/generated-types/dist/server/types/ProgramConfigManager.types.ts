/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * We need some way of knowing which domain we are talking with chain connection, execution, bridges for authorization.
 *
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` "^[a-zA-Z0-9-_]+$".
 */
export type Domain = {
  CosmosCosmwasm: string;
};
/**
 * What account type we talking about
 */
export type AccountType =
  | {
      Addr: {
        addr: string;
      };
    }
  | {
      Base: {
        admin?: string | null;
      };
    };
/**
 * A human readable address.
 *
 * In Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.
 *
 * This type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.
 *
 * This type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.
 */
export type Addr = string;
export type AuthorizationDuration =
  | "forever"
  | {
      seconds: number;
    }
  | {
      blocks: number;
    };
export type AuthorizationModeInfo =
  | "permissionless"
  | {
      permissioned: PermissionTypeInfo;
    };
export type PermissionTypeInfo =
  | {
      with_call_limit: [string, Uint128][];
    }
  | {
      without_call_limit: string[];
    };
/**
 * A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.
 *
 * # Examples
 *
 * Use `from` to create instances of this and `u128` to get the value out:
 *
 * ``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);
 *
 * let b = Uint128::from(42u64); assert_eq!(b.u128(), 42);
 *
 * let c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```
 */
export type Uint128 = string;
/**
 * Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)
 */
export type Expiration =
  | {
      at_height: number;
    }
  | {
      at_time: Timestamp;
    }
  | {
      never: {};
    };
/**
 * A point in time in nanosecond precision.
 *
 * This type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.
 *
 * ## Examples
 *
 * ``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);
 *
 * let ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```
 */
export type Timestamp = Uint64;
/**
 * A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.
 *
 * # Examples
 *
 * Use `from` to create instances of this and `u64` to get the value out:
 *
 * ``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);
 *
 * let b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```
 */
export type Uint64 = string;
export type Priority = "medium" | "high";
export type Subroutine =
  | {
      atomic: AtomicSubroutine;
    }
  | {
      non_atomic: NonAtomicSubroutine;
    };
/**
 * An account type that is used in the library configs It can either be an Id or Addr The config that will be passed to the library must be of Addr veriant
 */
export type LibraryAccountType =
  | {
      "|library_account_addr|": string;
    }
  | {
      "|account_id|": number;
    }
  | {
      "|library_id|": number;
    };
export type Domain2 =
  | "main"
  | {
      external: string;
    };
export type ParamRestriction =
  | {
      must_be_included: string[];
    }
  | {
      cannot_be_included: string[];
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      must_be_value: [string[], Binary];
    };
/**
 * Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.
 *
 * This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.
 */
export type Binary = string;
export type MessageType = "cosmwasm_execute_msg" | "cosmwasm_migrate_msg";
/**
 * Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined
 */
export type Duration =
  | {
      height: number;
    }
  | {
      time: number;
    };
export type RetryTimes =
  | "indefinitely"
  | {
      amount: number;
    };
export type LibraryConfigUpdate =
  | "None"
  | {
      ValenceForwarderLibrary: LibraryConfigUpdate2;
    }
  | {
      ValenceSplitterLibrary: LibraryConfigUpdate3;
    }
  | {
      ValenceReverseSplitterLibrary: LibraryConfigUpdate4;
    }
  | {
      ValenceAstroportLper: LibraryConfigUpdate5;
    }
  | {
      ValenceAstroportWithdrawer: LibraryConfigUpdate6;
    };
/**
 * A denom that has not been checked to confirm it points to a valid asset.
 */
export type UncheckedDenom =
  | {
      native: string;
    }
  | {
      cw20: string;
    };
export type UncheckedSplitAmount =
  | {
      fixed_amount: Uint128;
    }
  | {
      fixed_ratio: Decimal;
    }
  | {
      dynamic_ratio: {
        contract_addr: string;
        params: string;
      };
    };
/**
 * A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0
 *
 * The greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)
 */
export type Decimal = string;
export type UncheckedSplitAmount2 =
  | {
      fixed_amount: Uint128;
    }
  | {
      fixed_ratio: Decimal;
    }
  | {
      dynamic_ratio: {
        contract_addr: string;
        params: string;
      };
    };
export type PoolType =
  | {
      native_lp_token: PairType;
    }
  | {
      cw20_lp_token: PairType2;
    };
export type PairType =
  | {
      xyk: {};
    }
  | {
      stable: {};
    }
  | {
      custom: string;
    };
export type PairType2 =
  | {
      xyk: {};
    }
  | {
      stable: {};
    }
  | {
      custom: string;
    };
export type PoolType2 = "native_lp_token" | "cw20_lp_token";
export type AuthorizationInfoUpdate =
  | {
      Add: AuthorizationInfo;
    }
  | {
      Modify: {
        expiration?: Expiration | null;
        label: string;
        max_concurrent_executions?: number | null;
        not_before?: Expiration | null;
        priority?: Priority | null;
      };
    }
  | {
      Disable: string;
    }
  | {
      Enable: string;
    };

export interface SanitizedProgramConfig {
  program_config: ProgramConfig;
  program_config_update: ProgramConfigUpdate;
}
export interface ProgramConfig {
  /**
   * The list account data by id
   */
  accounts: {
    [k: string]: AccountInfo;
  };
  /**
   * This is the info regarding authorization and processor contracts. Must be empty (Default) when a new program is instantiated. It gets populated when the program is instantiated.
   */
  authorization_data?: AuthorizationData;
  /**
   * A list of authorizations
   */
  authorizations: AuthorizationInfo[];
  id?: number;
  /**
   * The list service data by id
   */
  libraries: {
    [k: string]: LibraryInfo;
  };
  /**
   * A list of links between an accounts and libraries
   */
  links: {
    [k: string]: Link;
  };
  owner: string;
  /**
   * Optional name of the program
   */
  name?: string;
}
/**
 * The struct given to us by the user.
 *
 * We need to know what domain we are talking with and what type of account we should work with.
 */
export interface AccountInfo {
  addr?: string | null;
  domain: Domain;
  name: string;
  ty: AccountType;
}
/**
 * This struct holds all the data regarding our authorization and processor contracts and bridge accounts
 */
export interface AuthorizationData {
  /**
   * authorization contract address on neutron
   */
  authorization_addr: string;
  /**
   * List of authorization bridge addresses by domain The addresses are on the specified domain Key: domain name | Value: authorization bridge address on that domain
   */
  authorization_bridge_addrs: {};
  /**
   * List of processor addresses by domain Key: domain name | Value: processor address
   */
  processor_addrs: {
    [k: string]: Addr;
  };
  /**
   * List of processor bridge addresses by domain All addresses are on nuetron, mapping to what domain this bridge account is for Key: domain name | Value: processor bridge address on that domain
   */
  processor_bridge_addrs: string[];
}
export interface AuthorizationInfo {
  duration: AuthorizationDuration;
  label: string;
  max_concurrent_executions?: number | null;
  mode: AuthorizationModeInfo;
  not_before: Expiration;
  priority?: Priority | null;
  subroutine: Subroutine;
}
export interface AtomicSubroutine {
  functions: AtomicFunction[];
  retry_logic?: RetryLogic | null;
}
export interface AtomicFunction {
  contract_address: LibraryAccountType;
  domain: Domain2;
  message_details: MessageDetails;
}
export interface MessageDetails {
  message: Message;
  message_type: MessageType;
}
export interface Message {
  name: string;
  params_restrictions?: ParamRestriction[] | null;
}
export interface RetryLogic {
  interval: Duration;
  times: RetryTimes;
}
export interface NonAtomicSubroutine {
  functions: NonAtomicFunction[];
}
export interface NonAtomicFunction {
  callback_confirmation?: FunctionCallback | null;
  contract_address: LibraryAccountType;
  domain: Domain2;
  message_details: MessageDetails;
  retry_logic?: RetryLogic | null;
}
export interface FunctionCallback {
  callback_message: Binary;
  contract_address: Addr;
}
export interface LibraryInfo {
  addr?: string | null;
  domain: Domain;
  name: string;
  config?: LibraryConfigUpdate;
}
export interface LibraryConfigUpdate2 {
  forwarding_configs?: UncheckedForwardingConfig[] | null;
  forwarding_constraints?: ForwardingConstraints | null;
  input_addr?: LibraryAccountType | null;
  output_addr?: LibraryAccountType | null;
}
/**
 * Struct representing an unchecked forwarding configuration.
 */
export interface UncheckedForwardingConfig {
  /**
   * The denom to be forwarded.
   */
  denom: UncheckedDenom;
  /**
   * The maximum amount of tokens to be transferred per forward operation.
   */
  max_amount: Uint128;
}
/**
 * Struct representing the time constraints on forwarding operations.
 */
export interface ForwardingConstraints {
  /**
   * The minimum interval between forwarding operations.
   */
  min_interval?: Duration | null;
}
export interface LibraryConfigUpdate3 {
  input_addr?: LibraryAccountType | null;
  splits?: UncheckedSplitConfig[] | null;
}
export interface UncheckedSplitConfig {
  account: LibraryAccountType;
  amount: UncheckedSplitAmount;
  denom: UncheckedDenom;
}
export interface LibraryConfigUpdate4 {
  base_denom?: UncheckedDenom | null;
  output_addr?: LibraryAccountType | null;
  splits?: UncheckedSplitConfig2[] | null;
}
export interface UncheckedSplitConfig2 {
  account: LibraryAccountType;
  amount: UncheckedSplitAmount2;
  denom: UncheckedDenom;
  factor?: number | null;
}
export interface LibraryConfigUpdate5 {
  input_addr?: LibraryAccountType | null;
  lp_config?: LiquidityProviderConfig | null;
  output_addr?: LibraryAccountType | null;
  pool_addr?: string | null;
}
export interface LiquidityProviderConfig {
  /**
   * Denoms of both native assets we are going to provide liquidity for
   */
  asset_data: AssetData;
  /**
   * Pool type, old Astroport pools use Cw20 lp tokens and new pools use native tokens, so we specify here what kind of token we are going to get. We also provide the PairType structure of the right Astroport version that we are going to use for each scenario
   */
  pool_type: PoolType;
  /**
   * Slippage tolerance when providing liquidity
   */
  slippage_tolerance?: Decimal | null;
}
export interface AssetData {
  /**
   * Denom of the first asset
   */
  asset1: string;
  /**
   * Denom of the second asset
   */
  asset2: string;
}
export interface LibraryConfigUpdate6 {
  input_addr?: LibraryAccountType | null;
  output_addr?: LibraryAccountType | null;
  pool_addr?: string | null;
  withdrawer_config?: LiquidityWithdrawerConfig | null;
}
export interface LiquidityWithdrawerConfig {
  /**
   * Pool type, old Astroport pools use Cw20 lp tokens and new pools use native tokens, so we specify here what kind of token we are going to get. We also provide the PairType structure of the right Astroport version that we are going to use for each scenario
   */
  pool_type: PoolType2;
}
export interface Link {
  /**
   * List of input accounts by id
   */
  input_accounts_id: number[];
  /**
   * The library id
   */
  library_id: number;
  /**
   * List of output accounts by id
   */
  output_accounts_id: number[];
}
/**
 * The job of the update, is to output a set of instructions to the user to update the program configuration. The user can only update library configs and authorizations.
 */
export interface ProgramConfigUpdate {
  /**
   * A list of authorizations
   */
  authorizations: AuthorizationInfoUpdate[];
  /**
   * This is the id of the program Required for update
   */
  id: number;
  /**
   * The list library data by id
   */
  libraries: {};
  /**
   * New owner, if the owner is to be updated
   */
  owner?: string | null;
}
