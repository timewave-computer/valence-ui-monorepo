/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import {
  InstantiateMsg,
  QueryMsg,
  IsmSpecifierQueryMsg,
  Expiration,
  Timestamp,
  Uint64,
  AuthorizationMode,
  PermissionType,
  Addr,
  Uint128,
  Priority,
  AuthorizationState,
  Subroutine,
  LibraryAccountType,
  Domain,
  ParamRestriction,
  Binary,
  MessageType,
  Duration,
  RetryTimes,
  ArrayOfAuthorization,
  Authorization,
  AtomicSubroutine,
  AtomicFunction,
  MessageDetails,
  Message,
  EncoderInfo,
  RetryLogic,
  NonAtomicSubroutine,
  NonAtomicFunction,
  FunctionCallback,
  ExecutionEnvironment,
  CosmwasmBridge,
  PolytoneProxyState,
  EvmBridge,
  ExternalDomain,
  PolytoneConnectors,
  PolytoneNote,
  Encoder,
  HyperlaneConnector,
  ArrayOfExternalDomain,
  InterchainSecurityModuleResponse,
  OwnershipForString,
  ExecutionResult,
  OperationInitiator,
  ProcessorMessage,
  ProcessorCallbackInfo,
  ArrayOfProcessorCallbackInfo,
  ArrayOfAddr,
} from "./Authorizations.types";
export interface AuthorizationsReadOnlyInterface {
  contractAddress: string;
  subOwners: () => Promise<ArrayOfAddr>;
  processor: () => Promise<Addr>;
  externalDomains: ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<ArrayOfExternalDomain>;
  externalDomain: ({ name }: { name: string }) => Promise<ExternalDomain>;
  authorizations: ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<ArrayOfAuthorization>;
  processorCallbacks: ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<ArrayOfProcessorCallbackInfo>;
  processorCallback: ({
    executionId,
  }: {
    executionId: number;
  }) => Promise<ProcessorCallbackInfo>;
  ismSpecifier: (
    ismSpecifierQueryMsg: IsmSpecifierQueryMsg
  ) => Promise<InterchainSecurityModuleResponse>;
  ownership: () => Promise<OwnershipForString>;
}
export class AuthorizationsQueryClient
  implements AuthorizationsReadOnlyInterface
{
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.subOwners = this.subOwners.bind(this);
    this.processor = this.processor.bind(this);
    this.externalDomains = this.externalDomains.bind(this);
    this.externalDomain = this.externalDomain.bind(this);
    this.authorizations = this.authorizations.bind(this);
    this.processorCallbacks = this.processorCallbacks.bind(this);
    this.processorCallback = this.processorCallback.bind(this);
    this.ismSpecifier = this.ismSpecifier.bind(this);
    this.ownership = this.ownership.bind(this);
  }
  subOwners = async (): Promise<ArrayOfAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      sub_owners: {},
    });
  };
  processor = async (): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      processor: {},
    });
  };
  externalDomains = async ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<ArrayOfExternalDomain> => {
    return this.client.queryContractSmart(this.contractAddress, {
      external_domains: {
        limit,
        start_after: startAfter,
      },
    });
  };
  externalDomain = async ({
    name,
  }: {
    name: string;
  }): Promise<ExternalDomain> => {
    return this.client.queryContractSmart(this.contractAddress, {
      external_domain: {
        name,
      },
    });
  };
  authorizations = async ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<ArrayOfAuthorization> => {
    return this.client.queryContractSmart(this.contractAddress, {
      authorizations: {
        limit,
        start_after: startAfter,
      },
    });
  };
  processorCallbacks = async ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<ArrayOfProcessorCallbackInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      processor_callbacks: {
        limit,
        start_after: startAfter,
      },
    });
  };
  processorCallback = async ({
    executionId,
  }: {
    executionId: number;
  }): Promise<ProcessorCallbackInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      processor_callback: {
        execution_id: executionId,
      },
    });
  };
  ismSpecifier = async (
    ismSpecifierQueryMsg: IsmSpecifierQueryMsg
  ): Promise<InterchainSecurityModuleResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ism_specifier: ismSpecifierQueryMsg,
    });
  };
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {},
    });
  };
}
